#!/usr/bin/env bash
set -euo pipefail

REAL_KSMSERVER="/usr/bin/ksmserver"
if [ -x /usr/bin/ksmserver.real ]; then
  REAL_KSMSERVER="/usr/bin/ksmserver.real"
fi

log() {
  echo "[steam-selkies][wrap:ksmserver] $*" >>/config/steam-selkies.log 2>/dev/null || true
}

log "wrapper_version=2026-01-13"

# ksmserver/libICE uses temporary lock/write files (iceauth_*) and may derive their
# mode from the current process umask. If the umask is unexpectedly restrictive,
# those files can become unwritable and ksmserver will SIGABRT.
um_before="$(umask 2>/dev/null || true)"
log "umask_before=${um_before}"
# Use a sane default umask for desktop components.
# NOTE: We still chmod authority files explicitly elsewhere.
umask 0022
log "umask_after=$(umask 2>/dev/null || true)"

pre_runtime="${XDG_RUNTIME_DIR:-}"

# XDG_RUNTIME_DIR should be on a local/ephemeral filesystem; /config can be a host bind
# mount or FUSE, which breaks atomic temp+lock behavior used by Qt/libICE (seen as
# EACCES on /config/.XDG/iceauth_* leading to SIGABRT).
if [ -z "${pre_runtime}" ] || printf '%s' "${pre_runtime}" | grep -q '^/config/'; then
  export XDG_RUNTIME_DIR="/tmp/.XDG"
fi

mkdir -p "${XDG_RUNTIME_DIR}" >/dev/null 2>&1 || true
chmod 700 "${XDG_RUNTIME_DIR}" >/dev/null 2>&1 || true

log "uid=$(id -u) gid=$(id -g) user=$(id -un 2>/dev/null || true) HOME=${HOME:-} DISPLAY=${DISPLAY:-} XDG_RUNTIME_DIR=${XDG_RUNTIME_DIR:-} ICEAUTHORITY=${ICEAUTHORITY:-} XAUTHORITY=${XAUTHORITY:-}"

# Workaround: we have observed libICE/Qt creating ${XDG_RUNTIME_DIR}/iceauth_* via
# O_TMPFILE+linkat such that the resulting file can be mode 000, and then failing to
# reopen it for writing (EACCES) which triggers SIGABRT inside ksmserver.
# A short-lived, fast poller fixes permissions immediately after creation.
if [ "${STEAM_DISABLE_ICEAUTH_TMP_PERMS_FIX:-0}" != "1" ]; then
  (
    set +e
    dir_watch="${XDG_RUNTIME_DIR}"
    start_ts=$(date +%s 2>/dev/null || echo 0)
    deadline=$(( start_ts + 8 ))
    iter=0
    max_iter=8000
    fixed=0
    while :; do
      iter=$((iter + 1))
      now=$(date +%s 2>/dev/null || echo 0)
      if [ ${start_ts} -gt 0 ]; then
        [ ${now} -ge ${deadline} ] && break
      else
        [ ${iter} -ge ${max_iter} ] && break
      fi

      for f in "${dir_watch}"/iceauth_*; do
        [ -e "$f" ] || continue

        # If the file is owner-unwritable (commonly mode 000/002), fix it immediately.
        # We avoid extra stat() calls here to reduce the race window.
        if [ ! -w "$f" ]; then
          chmod 600 "$f" >/dev/null 2>&1 && fixed=$((fixed + 1))
        fi
      done

      # Extremely short sleep to win the race; bounded loop duration keeps CPU impact low.
      # Busy-loop briefly at startup; then back off slightly.
      if [ ${iter} -lt 500 ]; then
        :
      else
        usleep 500 2>/dev/null || sleep 0.001 2>/dev/null || sleep 0.01 2>/dev/null || true
      fi
    done
    echo "[steam-selkies][wrap:ksmserver] iceauth_tmp_perms_fix: chmodded=${fixed} dir=${dir_watch}" >>/config/steam-selkies.log 2>/dev/null || true
  ) &
fi

if [ -n "${HOME:-}" ]; then
  if [ -e "${HOME}/.ICEauthority" ] || [ -L "${HOME}/.ICEauthority" ]; then
    log "HOME/.ICEauthority: $(ls -l "${HOME}/.ICEauthority" 2>/dev/null || true)"
    if command -v readlink >/dev/null 2>&1; then
      log "HOME/.ICEauthority-> $(readlink -f "${HOME}/.ICEauthority" 2>/dev/null || true)"
    fi
  else
    log "HOME/.ICEauthority: (missing)"
  fi
fi

# If ICEAUTHORITY is on /config (often a host bind mount), move it to /tmp to avoid
# libICE lock/link semantics failing on some FUSE-backed filesystems.
if [ -n "${ICEAUTHORITY:-}" ] && printf '%s' "${ICEAUTHORITY}" | grep -q '^/config/'; then
  export ICEAUTHORITY="/tmp/.ICEauthority-abc"
  log "ICEAUTHORITY rewritten to ${ICEAUTHORITY} (local fs)"
fi

if [ -n "${ICEAUTHORITY:-}" ]; then
  # Clear potential stale lock/temp files used by libICE/Xau locking.
  rm -f "${ICEAUTHORITY}-c" "${ICEAUTHORITY}-l" "${ICEAUTHORITY}.c" "${ICEAUTHORITY}.l" >/dev/null 2>&1 || true

  # Sanity check: can we create sibling files next to ICEAUTHORITY?
  ice_dir="$(dirname "${ICEAUTHORITY}")"
  testfile="${ice_dir}/.iceauth-write-test.$$"
  ( : >"${testfile}" ) >/dev/null 2>&1
  rc_touch=$?
  rm -f "${testfile}" >/dev/null 2>&1 || true
  if [ ${rc_touch} -ne 0 ]; then
    log "WARNING: cannot create files in ${ice_dir} (rc=${rc_touch}); libICE locking may fail"
  fi

  if [ -e "${ICEAUTHORITY}" ]; then
    log "ICEAUTHORITY exists: $(ls -l "${ICEAUTHORITY}" 2>/dev/null || true)"

    # Non-secret open test (does not read contents).
    head -c 0 "${ICEAUTHORITY}" >/dev/null 2>&1
    log "ICEAUTHORITY open-test rc=$?"
  else
    log "ICEAUTHORITY missing: ${ICEAUTHORITY}"
    touch "${ICEAUTHORITY}" 2>/dev/null || true
    chmod 600 "${ICEAUTHORITY}" 2>/dev/null || true
  fi

  # If the file is empty, seed it. KDE/ICE can treat an empty authority as unusable.
  if [ ! -s "${ICEAUTHORITY}" ] && command -v iceauth >/dev/null 2>&1; then
    # iceauth expects authdata as even-length hex (no 0x prefix).
    cookie_raw="$( (command -v mcookie >/dev/null 2>&1 && mcookie) || (openssl rand -hex 16 2>/dev/null) || echo "" )"
    cookie="$(printf '%s' "${cookie_raw}" | tr -cd '0-9a-fA-F' | tr 'A-F' 'a-f')"
    if [ $(( ${#cookie} % 2 )) -ne 0 ]; then
      cookie="${cookie%?}"
    fi

    if [ -n "${cookie}" ]; then
      set +e
      host="$(hostname 2>/dev/null || echo "")"
      netids=(
        "${DISPLAY:-}"
        "unix${DISPLAY:-}"
        "local/unix${DISPLAY:-}"
        "local/${DISPLAY:-}"
        "${host}/unix${DISPLAY:-}"
        "${host}${DISPLAY:-}"
        "localhost/unix${DISPLAY:-}"
        "localhost${DISPLAY:-}"
      )

      try_seed() {
        local mode="$1" # label
        local protocol_name="$2" # e.g. ICE
        local protocol_data="$3" # e.g. 0 or 1
        local tmpcmd

        tmpcmd="${TMPDIR:-/tmp}/iceauth.cmd.$$"
        {
          for netid in "${netids[@]}"; do
            [ -n "${netid}" ] || continue
            # Per iceauth(1): add protocol_name protocol_data netid authname authdata
            echo "remove ${protocol_name} ${protocol_data} ${netid} MIT-MAGIC-COOKIE-1"
            echo "add ${protocol_name} ${protocol_data} ${netid} MIT-MAGIC-COOKIE-1 ${cookie}"
          done
          echo "list"
          # IMPORTANT: 'exit' saves changes; 'quit' aborts changes.
          echo "exit"
        } >"${tmpcmd}" 2>/dev/null

        out_seed="$(iceauth -f "${ICEAUTHORITY}" <"${tmpcmd}" 2>&1)"
        rc_seed=$?
        rm -f "${tmpcmd}" >/dev/null 2>&1 || true
        size_seed="$(stat -c %s "${ICEAUTHORITY}" 2>/dev/null || echo 0)"

        log "ICEAUTHORITY seed ${mode} rc=${rc_seed} size=${size_seed}"
        # Do NOT log successful output: it contains cookie material.
        if [ -n "${out_seed}" ] && { [ ${rc_seed} -ne 0 ] || [ "${size_seed}" = "0" ]; }; then
          log "iceauth-${mode}: out=$(printf '%s' "${out_seed}" | tr '\n' ' ' | head -c 400)"
        fi

        [ "${size_seed}" != "0" ]
        return $?
      }

      # Try multiple syntaxes. Stop as soon as the file becomes non-empty.
      size0="$(stat -c %s "${ICEAUTHORITY}" 2>/dev/null || echo 0)"
      log "ICEAUTHORITY before-seed size=${size0}"
      log "ICEAUTHORITY seed cookie_hex_len=${#cookie}"

      # protocol_data must be even-length hex (e.g. 00, 01), not "0".
      try_seed "stdin-ICE-00" "ICE" "00" || \
      try_seed "stdin-ICE-01" "ICE" "01" || \
      try_seed "stdin-ICE-00000000" "ICE" "00000000" || true

      # Log a short listing (no secrets) so we can verify entries exist.
      list_out="$(iceauth -f "${ICEAUTHORITY}" list 2>/dev/null | head -n 5)"
      if [ -z "${list_out}" ]; then
        log "iceauth-list: (empty)"
      else
        printf '%s\n' "${list_out}" | while IFS= read -r line; do
          # Expected format: <protocol_name> <protocol_data> <netid> <authname> <authdata>
          set -- ${line}
          if [ "$#" -ge 4 ]; then
            log "iceauth-list: $1 $2 $3 $4 ***"
          else
            log "iceauth-list: ${line}"
          fi
        done
      fi

      log "ICEAUTHORITY final: $(ls -l "${ICEAUTHORITY}" 2>/dev/null || true)"

      set -e
    fi
  fi
fi

if [ "${STEAM_DEBUG_STRACE_KSMSERVER:-0}" = "1" ] && command -v strace >/dev/null 2>&1; then
  # IMPORTANT: do NOT run ksmserver *under* strace here. ksmserver/drkonqi often
  # fork/stop processes, which can keep `strace -f` alive indefinitely.
  # Instead, we attach for a short window to capture early ICE setup.
  trace_out="/config/ksmserver.filestrace.log"
  trace_seconds="${STEAM_DEBUG_STRACE_SECONDS:-8}"

  log "strace attach enabled: out=${trace_out} seconds=${trace_seconds} target_pid=$$"

  (
    set +e
    err_out="/config/ksmserver.strace.err.log"
    : >"${err_out}" 2>/dev/null || true
    echo "[steam-selkies][wrap:ksmserver] strace-attach: starting" >>/config/steam-selkies.log 2>/dev/null || true

    # Attach to this PID; after exec below, this PID becomes ksmserver.
    strace -f -qq -o "${trace_out}" -s 0 -e trace=file,process,network -p "$$" 2>"${err_out}" &
    spid=$!

    # Give it a bounded capture window, then detach.
    sleep "${trace_seconds}" 2>/dev/null || sleep 8
    kill -INT "${spid}" >/dev/null 2>&1 || true
    wait "${spid}" >/dev/null 2>&1 || true

    if [ -s "${err_out}" ]; then
      head -n 8 "${err_out}" | while IFS= read -r line; do
        echo "[steam-selkies][wrap:ksmserver] strace-err: ${line}" >>/config/steam-selkies.log 2>/dev/null || true
      done
    fi

    if [ ! -r "${trace_out}" ]; then
      echo "[steam-selkies][wrap:ksmserver] strace-ice: (trace not readable: ${trace_out})" >>/config/steam-selkies.log 2>/dev/null || true
      exit 0
    fi

    trace_size="$(stat -c %s "${trace_out}" 2>/dev/null || echo 0)"
    echo "[steam-selkies][wrap:ksmserver] strace-trace-size: ${trace_size}" >>/config/steam-selkies.log 2>/dev/null || true

    # Emit a compact summary.
    summary="$(grep -nEi "(ICEauthority|\\.ICEauthority|ICE-unix|\\.ICE-unix|/tmp/\\.X11-unix|Xauthority|\\.Xauthority|Xau|MIT-MAGIC-COOKIE)" "${trace_out}" | head -n 220)"
    if [ -z "${summary}" ]; then
      echo "[steam-selkies][wrap:ksmserver] strace-ice: (no matches; inspect ${trace_out})" >>/config/steam-selkies.log 2>/dev/null || true
    else
      printf '%s\n' "${summary}" | while IFS= read -r line; do
        echo "[steam-selkies][wrap:ksmserver] strace-ice: ${line}" >>/config/steam-selkies.log 2>/dev/null || true
      done
    fi

    # If we see ICE socket errors, emit a small context window around the first one.
    err_line="$(grep -nE "(ICE-unix|\\.ICE-unix).*(ECONNREFUSED|EACCES|EPERM|ENOENT|EADDRINUSE)" "${trace_out}" | head -n 1 | cut -d: -f1)"
    if [ -n "${err_line}" ]; then
      start=$((err_line - 30))
      [ ${start} -lt 1 ] && start=1
      end=$((err_line + 60))
      echo "[steam-selkies][wrap:ksmserver] strace-ice-context: around_line=${err_line}" >>/config/steam-selkies.log 2>/dev/null || true
      sed -n "${start},${end}p" "${trace_out}" | head -n 140 | while IFS= read -r line; do
        echo "[steam-selkies][wrap:ksmserver] strace-ice-context: ${line}" >>/config/steam-selkies.log 2>/dev/null || true
      done
    fi
  ) &
fi

exec "${REAL_KSMSERVER}" "$@"
